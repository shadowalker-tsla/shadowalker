export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const path = url.pathname;

    // Root path - simple info page
    if (path === '/' || path === '') {
      return new Response(`
        <html>
          <head><title>Tesla OAuth Callback Worker</title></head>
          <body style="font-family: Arial, sans-serif; padding: 40px; max-width: 800px; margin: auto;">
            <h1>Tesla Fleet API Callback Worker</h1>
            <p>This Worker handles OAuth callbacks and token refresh for your personal Tesla mileage tracker.</p>
            <p><strong>Callback endpoint:</strong> ${url.origin}/tesla-callback</p>
            <p><strong>Refresh endpoint:</strong> ${url.origin}/refresh (POST)</p>
            <p>Visit your site at <a href="https://theshadowalker.com">theshadowalker.com</a> to connect.</p>
          </body>
        </html>
      `, {
        headers: { 'Content-Type': 'text/html;charset=UTF-8' }
      });
    }

    // ────────────────────────────────────────────────
    // Initial OAuth callback: exchange code for tokens
    // ────────────────────────────────────────────────
    if (path === '/tesla-callback') {
      console.log('Callback hit → query:', url.search);

      const code = url.searchParams.get('code');
      const state = url.searchParams.get('state') || 'no-state';

      if (!code) {
        return new Response('Missing authorization code parameter. This endpoint is for Tesla OAuth callback only.', { status: 400 });
      }

      const CLIENT_ID = env.CLIENT_ID;
      const CLIENT_SECRET = env.CLIENT_SECRET;

      if (!CLIENT_ID || !CLIENT_SECRET) {
        console.error('Missing secrets in Worker');
        return new Response('Server error: missing Client ID or Secret', { status: 500 });
      }

      const REDIRECT_URI = url.origin + '/tesla-callback';

      try {
        console.log('Exchanging code for tokens...');

        const tokenResponse = await fetch('https://auth.tesla.com/oauth2/v3/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'authorization_code',
            client_id: CLIENT_ID,
            client_secret: CLIENT_SECRET,
            code: code,
            redirect_uri: REDIRECT_URI
          })
        });

        const text = await tokenResponse.text();

        if (!tokenResponse.ok) {
          console.error('Token exchange failed:', tokenResponse.status, text);
          return new Response(`Token exchange failed: ${tokenResponse.status} - ${text}`, { status: 500 });
        }

        const tokens = JSON.parse(text);

        console.log('Tokens received successfully');

        // Redirect back to main site with tokens in fragment
        const fragment = new URLSearchParams({
          access_token: tokens.access_token,
          refresh_token: tokens.refresh_token,
          expires_in: tokens.expires_in,
          state: state
        }).toString();

        return Response.redirect(`https://theshadowalker.com/#${fragment}`, 302);
      } catch (err) {
        console.error('Callback error:', err.message, err.stack);
        return new Response(`Internal error during callback: ${err.message}`, { status: 500 });
      }
    }

    // ────────────────────────────────────────────────
    // Refresh endpoint: get new access token
    // ────────────────────────────────────────────────
    if (path === '/refresh') {
      if (request.method !== 'POST') {
        return new Response('Method Not Allowed - use POST', { status: 405 });
      }

      let body;
      try {
        body = await request.json();
      } catch {
        return new Response('Invalid JSON body', { status: 400 });
      }

      const refreshToken = body.refresh_token;
      if (!refreshToken) {
        return new Response('Missing refresh_token in body', { status: 400 });
      }

      const CLIENT_ID = env.CLIENT_ID;
      const CLIENT_SECRET = env.CLIENT_SECRET;

      if (!CLIENT_ID || !CLIENT_SECRET) {
        return new Response('Server error: missing secrets', { status: 500 });
      }

      try {
        console.log('Refreshing token...');

        const tokenResponse = await fetch('https://auth.tesla.com/oauth2/v3/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            grant_type: 'refresh_token',
            client_id: CLIENT_ID,
            client_secret: CLIENT_SECRET,
            refresh_token: refreshToken
          })
        });

        const text = await tokenResponse.text();

        if (!tokenResponse.ok) {
          console.error('Refresh failed:', tokenResponse.status, text);
          return new Response(text || 'Refresh failed', { status: tokenResponse.status });
        }

        const tokens = JSON.parse(text);

        return new Response(JSON.stringify({
          access_token: tokens.access_token,
          refresh_token: tokens.refresh_token || refreshToken, // sometimes re-issued
          expires_in: tokens.expires_in
        }), {
          headers: { 'Content-Type': 'application/json' }
        });
      } catch (err) {
        console.error('Refresh error:', err.message, err.stack);
        return new Response(`Internal refresh error: ${err.message}`, { status: 500 });
      }
    }

    // Fallback for unknown paths
    return new Response('Not Found', { status: 404 });
  }
};